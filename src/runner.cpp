#include "runner.h"

#include <v8/src/snapshot/code-serializer.h>
#include <v8/src/objects/shared-function-info.h>
#include <v8/src/handles/handles.h>
#include <v8/src/codegen/compiler.h>
#include <v8/src/utils/ostreams.h>
#include <v8/src/handles/handles-inl.h>
#include "src/objects/objects-inl.h"

#include "utils.h"
#include "shell.h"
#include "cache.h"

namespace v8 {
    namespace i = v8::internal;
}

namespace dejsc {
namespace Runner {

using namespace v8::internal;

std::unique_ptr<v8::Platform> gDefaultPlatform = v8::platform::NewDefaultPlatform();


static Handle<SharedFunctionInfo> CompileScript(
        Isolate* isolate, Handle<String> source, Handle<String> name,
        ScriptData* cached_data, v8::ScriptCompiler::CompileOptions options,
        v8::ScriptOriginOptions origin_option) {
    return Compiler::GetSharedFunctionInfoForScript(
                isolate, source, Compiler::ScriptDetails(name),
                origin_option, nullptr, cached_data, options,
                v8::ScriptCompiler::kNoCacheNoReason, NOT_NATIVES_CODE)
        .ToHandleChecked();
}


static Handle<SharedFunctionInfo> CompileScriptAndProduceCache(
        Isolate* isolate, Handle<String> source, Handle<String> name,
        ScriptData** script_data, v8::ScriptCompiler::CompileOptions options) {
    Handle<SharedFunctionInfo> sfi =
        Compiler::GetSharedFunctionInfoForScript(
            isolate, source, Compiler::ScriptDetails(name),
            v8::ScriptOriginOptions(), nullptr, nullptr, options,
            v8::ScriptCompiler::kNoCacheNoReason, NOT_NATIVES_CODE)
            .ToHandleChecked();
    std::unique_ptr<v8::ScriptCompiler::CachedData> cached_data(
        v8::ScriptCompiler::CreateCodeCache(v8::ToApiHandle<v8::UnboundScript>(sfi)));
    uint8_t* buffer = NewArray<uint8_t>(cached_data->length);
    MemCopy(buffer, cached_data->data, cached_data->length);
    *script_data = new i::ScriptData(buffer, cached_data->length);
    (*script_data)->AcquireDataOwnership();
    return sfi;
}

static void Disassemble(v8::i::Handle<v8::i::SharedFunctionInfo> fun);

static void DisassembleFixedArray(v8::i::Handle<v8::i::FixedArray> array, v8::i::Isolate *isolate) {
    for (int i = 0; i < array->length(); i++) {
        auto obj = v8::i::handle(array->get(i), isolate);
        if (obj->IsSharedFunctionInfo()) {
            Handle<SharedFunctionInfo> sfi = v8::i::Handle<v8::i::SharedFunctionInfo>::cast(obj);
            if (!sfi->HasBytecodeArray())
                continue;
            Disassemble(sfi);
        } else if (obj->IsFixedArray()) {
            auto array = v8::i::Handle<v8::i::FixedArray>::cast(obj);
            DisassembleFixedArray(array, isolate);
        }
    }
}

static void Disassemble(v8::i::Handle<v8::i::SharedFunctionInfo> fun) {
    v8::i::StdoutStream os;
    auto isolate = fun->GetIsolate();
    os << "[generated bytecode for function: " << fun->Name().ToCString().get() << " ("
        << fun << ")]" << std::endl;
    Handle<BytecodeArray> bytecode = handle(fun->GetBytecodeArray(isolate), isolate);
    bytecode->Disassemble(os);
    os << std::flush;

    DisassembleFixedArray(v8::i::handle(bytecode->constant_pool(), isolate), isolate);
}

void CompileToCache(
    const std::string &js_filename,
    const std::string &output_filename,
    v8::Isolate* isolate,
    v8::Local<v8::Context> &context)
{
    std::string raw_code = dejsc::IO::read_file(js_filename);
    std::unique_ptr<v8::ScriptCompiler::CachedData> cache;

    {
        v8::Local<v8::String> source_string = StrUtil::v8_str(raw_code.c_str());
        v8::ScriptOrigin script_origin(StrUtil::v8_str(js_filename.c_str()));
        v8::ScriptCompiler::Source source(source_string, script_origin);
        v8::TryCatch try_catch(isolate);
        v8::ScriptCompiler::CompileOptions option =
            v8::ScriptCompiler::kEagerCompile;
        v8::Local<v8::UnboundScript> script;

        if (!v8::ScriptCompiler::CompileUnboundScript(isolate, &source, option).ToLocal(&script)) {
            Shell::ReportException(isolate, &try_catch);
            return;
        } else {
            cache.reset(v8::ScriptCompiler::CreateCodeCache(script));
        }
        
    }

    dejsc::IO::write_file(output_filename, (char *)cache->data, cache->length);
}

void CompileModuleToCache(
    const std::string &js_filename,
    const std::string &output_filename,
    v8::Isolate* isolate,
    v8::Local<v8::Context> &context)
{
    std::string raw_code = dejsc::IO::read_file(js_filename);
    std::unique_ptr<v8::ScriptCompiler::CachedData> cache;

    {
        v8::Local<v8::String> source_string = StrUtil::v8_str(raw_code.c_str());

        auto url = StrUtil::v8_str(js_filename.c_str());
        v8::ScriptOrigin origin(url,
                                0,
                                0,
                                true,                             // is cross origin
                                -1,                               // script id
                                v8::Local<v8::Value>(),                   // source map URL
                                false,                            // is opaque (?)
                                false,                            // is WASM
                                true,                             // is ES Module
                                v8::Local<v8::PrimitiveArray>());

        v8::ScriptCompiler::Source source(source_string, origin);
        v8::TryCatch try_catch(isolate);
        v8::ScriptCompiler::CompileOptions option =
            v8::ScriptCompiler::kEagerCompile;
        v8::Local<v8::Module> module;
        if (!v8::ScriptCompiler::CompileModule(isolate, &source, option).ToLocal(&module)) {
            Shell::ReportException(isolate, &try_catch);
            return;
        }

        v8::Local<v8::UnboundModuleScript> unbound_module_script =
            module->GetUnboundModuleScript();
        cache.reset(
            v8::ScriptCompiler::CreateCodeCache(unbound_module_script));
    }

    std::unique_ptr<ScriptData> data;
    uint8_t* buffer = NewArray<uint8_t>(cache->length);
    MemCopy(buffer, cache->data, cache->length);
    data.reset(new i::ScriptData(buffer, cache->length));
    data->AcquireDataOwnership();

    dejsc::IO::write_file(output_filename, (char *)data->data(), data->length());
}

int RunBytecodeCache(const std::string &cache_filename, bool print_result, v8::Isolate* isolate, v8::Local<v8::Context> context)
{
    Cache::CachedCode cache(cache_filename);

    std::string fake_source(cache.GetSourceHash(), ' ');
    v8::Local<v8::String> source_string = StrUtil::v8_str(fake_source.c_str());
    v8::ScriptOrigin script_origin(StrUtil::v8_str(cache_filename.c_str()));
    v8::ScriptCompiler::Source source_obj(source_string, script_origin, cache.GetCachedData().release());
    v8::ScriptCompiler::CompileOptions option = v8::ScriptCompiler::kConsumeCodeCache;

    v8::Local<v8::Script> script;
    {
        v8::TryCatch try_catch(isolate);
        i::DisallowCompilation no_compile(
            reinterpret_cast<i::Isolate*>(isolate));
        if (!v8::ScriptCompiler::Compile(context, &source_obj, option).ToLocal(&script)) {
            Shell::ReportException(isolate, &try_catch);
            return 1;
        }

        if (source_obj.GetCachedData()->rejected) {
            std::cerr << "cached data was rejected" << std::endl;
        }
    }

    bool ok = dejsc::Shell::ExecuteCompiledScript(isolate, context, script, print_result, true);
    while (v8::platform::PumpMessageLoop(gDefaultPlatform.get(), isolate)) continue;

    return ok ? 0 : 1;
}


int RunJavaScriptCode(const std::string &jscode, bool print_result, v8::Isolate* isolate, v8::Local<v8::Context> context)
{
    // Execute argument given to -e option directly.
    v8::Local<v8::String> file_name =
        v8::String::NewFromUtf8(isolate, "unnamed",
                                v8::NewStringType::kNormal).ToLocalChecked();
    v8::Local<v8::String> source;
    if (!v8::String::NewFromUtf8(isolate, jscode.c_str(),
                                v8::NewStringType::kNormal)
            .ToLocal(&source)) {
        return 1;
    }
    bool success = dejsc::Shell::ExecuteString(isolate, source, file_name, print_result, true);
    while (v8::platform::PumpMessageLoop(gDefaultPlatform.get(), isolate)) continue;

    return success ? 0 : 1;
}


int RunJavaScriptFile(const std::string &js_filename, bool print_result, v8::Isolate* isolate, v8::Local<v8::Context> context)
{
    std::string raw_code = dejsc::IO::read_file(js_filename);
    // Use all other arguments as names of files to load and run.
    v8::Local<v8::String> file_name =
        v8::String::NewFromUtf8(isolate, js_filename.c_str(), v8::NewStringType::kNormal)
            .ToLocalChecked();
    v8::Local<v8::String> source;
    if (!dejsc::Shell::ReadFile(
            isolate, js_filename.c_str()).ToLocal(&source)) {
        fprintf(stderr, "Error reading '%s'\n", js_filename.c_str());
    }
    bool success = dejsc::Shell::ExecuteString(isolate, source, file_name, print_result, true);
    while (v8::platform::PumpMessageLoop(gDefaultPlatform.get(), isolate)) continue;

    return success ? 0 : 1;
}


int RunInV8(
    std::function<int (v8::Isolate*, v8::Local<v8::Context>&) > callback,
    bool use_shell_context /*= false*/)
{
    v8::Isolate::CreateParams create_params;
    create_params.array_buffer_allocator =
        v8::ArrayBuffer::Allocator::NewDefaultAllocator();
    v8::Isolate* isolate = v8::Isolate::New(create_params);

    int result;
    {
        v8::Isolate::Scope isolate_scope(isolate);
        v8::HandleScope handle_scope(isolate);

        v8::Local<v8::Context> context;
        if (use_shell_context)
            context = dejsc::Shell::CreateShellContext(isolate);
        else
            context = v8::Context::New(isolate);

        if (context.IsEmpty()) {
            fprintf(stderr, "Error creating context\n");
            return 1;
        }

        v8::Context::Scope context_scope(context);

        // Run given function in the environment that has been set up.
        result = callback(isolate, context);
    }

    // Dispose the isolate
    isolate->Dispose();
    delete create_params.array_buffer_allocator;

    return result;
}

int DisassembleBytecodeCache(const std::string &cache_filename, v8::Isolate* isolate, v8::Local<v8::Context> context) {
    Cache::CachedCode cache(cache_filename);

    std::string fake_source(cache.GetSourceHash(), ' ');
    v8::ScriptOriginOptions options_(true, false, false, false);
    auto iso = reinterpret_cast<v8::i::Isolate*>(isolate);
    auto source = iso->factory()
                    ->NewStringFromUtf8(CStrVector(fake_source.c_str()))
                    .ToHandleChecked();
    auto fun = v8::i::CodeSerializer::Deserialize(iso, cache.GetScriptData().get(), source, options_)
                   .ToHandleChecked();
    Disassemble(fun);
}

} // namespace Runner
} // namespace dejsc